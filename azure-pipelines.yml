stages:
  - stage:
    displayName: Build
    jobs:
      # Win64 VS2017
      - template: Build/azure-pipelines/windows-build-job-template.yml
        parameters:
          name: Win64_VS2017
          vsVersion: '2017'
          platform: 'x64'
          llvmBuildBaseName: 'Win64'
          llvmVersion: '9.x'

      # Win64 VS2019
      - template: Build/azure-pipelines/windows-build-job-template.yml
        parameters:
          name: Win64_VS2019
          vsVersion: '2019'
          platform: 'x64'
          llvmBuildBaseName: 'Win64'
          llvmVersion: '9.x'

      # Win32 VS2019
      - template: Build/azure-pipelines/windows-build-job-template.yml
        parameters:
          name: Win32_VS2019
          vsVersion: '2019'
          platform: 'x86'
          llvmBuildBaseName: 'Win32'
          llvmVersion: '9.x'

      # Ubuntu 16.04 GCC
      - template: Build/azure-pipelines/posix-build-job-template.yml
        parameters:
          name: Ubuntu1604_GCC
          vmImage: 'ubuntu-16.04'
          container: 'wavm/ubuntu16.04-builder:latest'
          llvmBuildBaseName: 'Ubuntu1604'
          llvmVersion: '9.x'
          cpackGenerators: 'TGZ;DEB'
          compiler: 'gcc'

      # Ubuntu 16.04 Clang
      - template: Build/azure-pipelines/posix-build-job-template.yml
        parameters:
          name: Ubuntu1604_Clang
          vmImage: 'ubuntu-16.04'
          container: 'wavm/ubuntu16.04-builder:latest'
          llvmBuildBaseName: 'Ubuntu1604'
          llvmVersion: '9.x'
          cpackGenerators: 'TGZ;DEB'
          compiler: 'clang'

      # CentOS 7.0 Clang
      - template: Build/azure-pipelines/posix-build-job-template.yml
        parameters:
          name: CentOS70_Clang
          vmImage: 'ubuntu-16.04'
          container: 'wavm/centos7.0-builder:latest'
          llvmBuildBaseName: 'Centos70'
          llvmVersion: '9.x'
          cpackGenerators: 'TGZ;RPM'
          compiler: 'clang'

      # MacOS 10.14
      - template: Build/azure-pipelines/posix-build-job-template.yml
        parameters:
          name: MacOS
          vmImage: 'macOS-10.14'
          llvmBuildBaseName: 'MacOS'
          llvmVersion: '9.x'
          cpackGenerators: 'TGZ'
          compiler: 'appleClang'
          toolchainInstallSteps:
            - script: brew install ninja
              displayName: Install Ninja


  - stage:
    # Only upload a "nightly" build if this is the scheduled build of the master branch (implies it's not a pull request).
    condition:
      and(
        succeeded(),
        or(
          and(
            eq(variables['Build.SourceBranch'], 'refs/heads/master'),
            eq(variables['Build.Reason'], 'Schedule')
          ),
          eq(variables['WAVM.ForceNightlyRelease'], 'true')
        )
      )
    displayName: Create nightly GitHub release
    jobs:
      - job: UploadGitHubRelease
        pool:
          vmImage: macOS-10.14
        steps:
        - checkout: self
          persistCredentials: true

        # Download all the artifacts uploaded by the jobs in the Build stage.
        - task: DownloadPipelineArtifact@2
          inputs:
            buildType: current
            targetPath: $(Build.ArtifactStagingDirectory)

        # Get the today's date for CI builds, or yesterday's date for the 1AM scheduled nightly build.
        # All dates are New York time (the scheduled build is also at 1AM New York time)
        - ${{if not(eq(variables['Build.Reason'], 'Schedule'))}}:
            - bash: echo "##vso[task.setvariable variable=buildDate]$(TZ=America/New_York date +%Y-%m-%d)"
              displayName: Read today's date
        - ${{if eq(variables['Build.Reason'], 'Schedule')}}:
            - bash: echo "##vso[task.setvariable variable=buildDate]$(TZ=America/New_York date --date=yesterday +%Y-%m-%d)"
              displayName: Read yesterday's date

        # Check whether this nightly release already exists.
        - bash: |
            # Just fetch the release URL instead of querying the API, since API requests from the
            # Azure Pipelines agents are often rate limited by GitHub.
            #if [[ $(curl --write-out %{http_code} --silent --output /dev/null https://api.github.com/repos/WAVM/WAVM/releases/tags/nightly/$(buildDate)) = 200 ]]
            if [[ $(curl --write-out %{http_code} --silent --output /dev/null https://github.com/WAVM/WAVM/releases/tag/nightly%2F$(buildDate)) = 200 ]]
            then
              echo "##vso[task.setvariable variable=deleteOldRelease]true"
              echo "Found old release with the build's date"
            else
              echo "##vso[task.setvariable variable=deleteOldRelease]false"
              echo "Did not find old release with the build's date"
            fi
          displayName: Check for existing release

        # If there's an old version of this release, delete the old GitHub release.
        - task: GitHubRelease@0
          condition: and(succeeded(), eq(variables.deleteOldRelease, 'true'))
          displayName: Delete old GitHub release
          inputs:
            gitHubConnection: GitHub-WAVM-AzurePipelines
            action: 'delete'
            tag: nightly/$(buildDate)

        # Delete the old tag on GitHub.
        - script: |
            git -c http.extraheader="AUTHORIZATION: basic ***" push origin :nightly/$(buildDate)
          displayName: Delete old GitHub release tag
          condition: and(succeeded(), eq(variables.deleteOldRelease, 'true'))

        # Rename and move the packages we want to add to the release into a separate folder.
        - script: |
            VERSION=$(cat $(Build.SourcesDirectory)/VERSION)
            mkdir -p release
            mv Win64_VS2019_LTO/wavm.exe release/wavm-$VERSION-windows.exe
            mv Win64_VS2019_LTO/wavm.zip release/wavm-$VERSION-windows.zip
            mv MacOS_StaticLTO/wavm.tar.gz release/wavm-$VERSION-macos.tar.gz
            mv Ubuntu1604_Clang_LTO/wavm.deb release/wavm-$VERSION-linux.deb
            mv CentOS70_Clang_LTO/wavm.rpm release/wavm-$VERSION-linux.rpm
            mv CentOS70_Clang_StaticLTO/wavm.tar.gz release/wavm-$(VERSION)-linux.tar.gz
          cwd: $(Build.ArtifactStagingDirectory)
          displayName: Stage release artifacts

        # Create a GitHub release containing the artifacts.
        - task: GitHubRelease@0
          inputs:
            gitHubConnection: GitHub-WAVM-AzurePipelines
            displayName: Create GitHub release
            action: create
            target: $(Build.SourceVersion)
            tagSource: manual
            tag: nightly/$(buildDate)
            assets: $(Build.ArtifactStagingDirectory)/release/*
            releaseNotesSource: input
            releaseNotes: 
            addChangeLog: true
            changeLogCompareToRelease: lastNonDraftReleaseByTag
            changeLogCompareToReleaseTag: nightly[\-/][\d\-]+
            isPreRelease: true


  - stage:
    displayName: Notify Discord
    condition: always()
    jobs:
      - job: NotifyDiscord
        displayName: Notify Discord (succeeded)
        condition: succeeded()
        pool: { vmImage: macOS-10.14 }
        steps:
        - bash: $(Build.SourcesDirectory)/Build/notify-discord.sh success $DISCORD_WEBHOOK_URL
          displayName: Notify Discord
          env: { DISCORD_WEBHOOK_URL: $(DISCORD_WEBHOOK_URL) }
      - job: NotifyDiscord
        displayName: Notify Discord (failed)
        condition: failed()
        pool: { vmImage: macOS-10.14 }
        steps:
        - bash: $(Build.SourcesDirectory)/Build/notify-discord.sh failed $DISCORD_WEBHOOK_URL
          displayName: Notify Discord
          env: { DISCORD_WEBHOOK_URL: $(DISCORD_WEBHOOK_URL) }